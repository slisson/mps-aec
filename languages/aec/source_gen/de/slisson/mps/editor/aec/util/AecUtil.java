package de.slisson.mps.editor.aec.util;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.smodel.SNode;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.kernel.model.SModelUtil;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.smodel.LanguageAspect;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.project.structure.modules.ModuleReference;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.util.IterableUtil;
import java.util.Queue;
import jetbrains.mps.internal.collections.runtime.QueueSequence;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.nodeEditor.cells.EditorCell;
import jetbrains.mps.nodeEditor.EditorContext;
import jetbrains.mps.nodeEditor.cells.EditorCell_Error;
import jetbrains.mps.lang.core.behavior.INamedConcept_Behavior;
import jetbrains.mps.nodeEditor.AbstractCellProvider;
import jetbrains.mps.logging.Logger;
import jetbrains.mps.project.ClassLoadingModule;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import jetbrains.mps.smodel.DefaultSModelDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;

public class AecUtil {
  public AecUtil() {
  }

  public static List<SNode> findAbstractEditorComponents(SNode concept) {
    return getAbstractEditorComponents(findEditorDeclaration(concept));
  }

  public static List<SNode> getAbstractEditorComponents(SNode editorDecl) {
    List<SNode> result = new ArrayList<SNode>();
    ListSequence.fromList(result).addSequence(ListSequence.fromList(SNodeOperations.getDescendants(SLinkOperations.getTarget(editorDecl, "cellModel", true), "de.slisson.mps.editor.aec.structure.AbstractEditorComponent", false, new String[]{})));
    ListSequence.fromList(result).addSequence(ListSequence.fromList(SNodeOperations.getDescendants(SLinkOperations.getTarget(editorDecl, "inspectedCellModel", true), "de.slisson.mps.editor.aec.structure.AbstractEditorComponent", false, new String[]{})));
    return result;
  }

  public static SNode findEditorDeclaration(SNode concept) {
    for (SNode superConcept : ListSequence.fromList(SConceptOperations.getConceptHierarchy(concept))) {
      SNode editorDecl = findEditorDeclarationByConcept(superConcept);
      if (editorDecl != null) {
        return editorDecl;
      }
    }
    return null;
  }

  public static SNode findEditorDeclarationByConcept(final SNode concept) {
    Language language = SModelUtil.getDeclaringLanguage(concept);
    if (language == null) {
      return null;
    }
    SModelDescriptor editorModelDesriptor = LanguageAspect.EDITOR.get(language);
    SModel editorModel = editorModelDesriptor.getSModel();
    return ListSequence.fromList(SModelOperations.getRoots(editorModel, "jetbrains.mps.lang.editor.structure.ConceptEditorDeclaration")).findFirst(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SLinkOperations.getTarget(it, "conceptDeclaration", false) == concept;
      }
    });
  }

  public static SNode findConcreteComponent(SNode nodeConcept, String componentName, SModel model) {
    List<ModuleReference> langRefs = ListSequence.fromList(new ArrayList<ModuleReference>());
    ListSequence.fromList(langRefs).addSequence(CollectionSequence.fromCollection(IterableUtil.asCollection(model.getModelDepsManager().getAllImportedLanguages())));

    final Queue<SNode> conceptQueue = QueueSequence.fromQueue(new LinkedList<SNode>());
    Set<SNode> processedConcepts = SetSequence.fromSet(new HashSet<SNode>());
    QueueSequence.fromQueue(conceptQueue).addLastElement(nodeConcept);
    while (QueueSequence.fromQueue(conceptQueue).isNotEmpty()) {
      SNode abstractConceptDeclaration = QueueSequence.fromQueue(conceptQueue).removeFirstElement();
      if (SetSequence.fromSet(processedConcepts).contains(abstractConceptDeclaration)) {
        continue;
      } else {
        SetSequence.fromSet(processedConcepts).addElement(abstractConceptDeclaration);
      }
      SNode editorComponent = getConcreteComponentByConcept(abstractConceptDeclaration, componentName, langRefs);
      if ((editorComponent != null)) {
        return editorComponent;
      }
      if (SNodeOperations.isInstanceOf(abstractConceptDeclaration, "jetbrains.mps.lang.structure.structure.ConceptDeclaration")) {
        SNode conceptDeclaration = SNodeOperations.cast(abstractConceptDeclaration, "jetbrains.mps.lang.structure.structure.ConceptDeclaration");
        if (SLinkOperations.getTarget(conceptDeclaration, "extends", false) != null && SLinkOperations.getTarget(conceptDeclaration, "extends", false) != SConceptOperations.findConceptDeclaration("jetbrains.mps.lang.core.structure.BaseConcept")) {
          QueueSequence.fromQueue(conceptQueue).addLastElement(SLinkOperations.getTarget(conceptDeclaration, "extends", false));
        }
        ListSequence.fromList(SLinkOperations.getTargets(conceptDeclaration, "implements", true)).visitAll(new IVisitor<SNode>() {
          public void visit(SNode it) {
            QueueSequence.fromQueue(conceptQueue).addLastElement(SLinkOperations.getTarget(it, "intfc", false));
          }
        });
      } else if (SNodeOperations.isInstanceOf(abstractConceptDeclaration, "jetbrains.mps.lang.structure.structure.InterfaceConceptDeclaration")) {
        ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(abstractConceptDeclaration, "jetbrains.mps.lang.structure.structure.InterfaceConceptDeclaration"), "extends", true)).visitAll(new IVisitor<SNode>() {
          public void visit(SNode it) {
            QueueSequence.fromQueue(conceptQueue).addLastElement(SLinkOperations.getTarget(it, "intfc", false));
          }
        });
      }
    }
    return null;
  }

  public static EditorCell createConcreteEditorCell(SNode nodeToEdit, String componentName, EditorContext editorContext) {
    EditorCell result;
    try {
      SNode concreteComponent = findConcreteComponent(nodeToEdit, componentName);
      if (concreteComponent == null) {
        result = new EditorCell_Error(editorContext, nodeToEdit, "Concrete Component '" + componentName + "' not found");
      } else {
        SModelOperations.getModuleStub(SNodeOperations.getModel(nodeToEdit));
        Class concreteClass = loadClass(INamedConcept_Behavior.call_getFqName_1213877404258(concreteComponent), SModelOperations.getModuleStub(SNodeOperations.getModel(concreteComponent)));
        AbstractCellProvider provider = (AbstractCellProvider) concreteClass.getConstructor(SNode.class).newInstance(nodeToEdit);
        result = provider.createEditorCell(editorContext);
      }
    } catch (Exception ex) {
      result = new EditorCell_Error(editorContext, nodeToEdit, "Failed to load concrete component for '" + componentName + "'.");

      Logger.getLogger("de.slisson.mps.editor.aec.AecUtil").error("Failed to load concrete componenten for '" + componentName + "'.", ex);
    }

    return result;
  }

  public static SNode findConcreteComponent(final SNode nodeToEdit, String componentName) {
    return findConcreteComponent(SNodeOperations.getConceptDeclaration(nodeToEdit), componentName, SNodeOperations.getModel(nodeToEdit));
  }

  public static Class loadClass(String classFqName, SNode moduleNode) throws ClassNotFoundException {
    Class result;
    ClassLoadingModule module = ModuleRepositoryFacade.getInstance().getModule(INamedConcept_Behavior.call_getFqName_1213877404258(moduleNode), ClassLoadingModule.class);
    if (module == null) {
      result = Class.forName(classFqName);
    } else {
      result = Class.forName(classFqName, true, module.getClassLoader());
    }
    return result;
  }

  public static SNode getConcreteComponentByConcept(SNode concept, String componentName, List<ModuleReference> languageModules) {
    for (ModuleReference mod : ListSequence.fromList(languageModules)) {
      Language lang = ModuleRepositoryFacade.getInstance().getModule(mod.getModuleFqName(), Language.class);
      DefaultSModelDescriptor editorModelDescriptor = LanguageAspect.EDITOR.get(lang);
      SModel editorModel = editorModelDescriptor.getSModel();
      for (SNode componentDecl : ListSequence.fromList(SModelOperations.getRoots(editorModel, "de.slisson.mps.editor.aec.structure.ConcreteEditorComponent"))) {
        if (eq_4hvxy8_a0a0a3a0a8_0(INamedConcept_Behavior.call_getFqName_1213877404258(SLinkOperations.getTarget(componentDecl, "conceptDeclaration", false)), INamedConcept_Behavior.call_getFqName_1213877404258(concept)) && eq_4hvxy8_a0a0a3a0a8(SPropertyOperations.getString(SLinkOperations.getTarget(componentDecl, "abstractComponent", false), "name"), componentName)) {
          return componentDecl;

        }
      }
    }
    return null;
  }

  private static boolean eq_4hvxy8_a0a0a3a0a8(Object a, Object b) {
    return (a != null ?
      a.equals(b) :
      a == b
    );
  }

  private static boolean eq_4hvxy8_a0a0a3a0a8_0(Object a, Object b) {
    return (a != null ?
      a.equals(b) :
      a == b
    );
  }
}
